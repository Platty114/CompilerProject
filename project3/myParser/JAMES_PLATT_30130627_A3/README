James Platt 30130627
CPSC 411 Assignment 3

Hi There!

This is my submission for cpsc 411 assignment 3.
I have implemented all the checks as specified in the outline and included a sweet of
tests for these checks under /tests. I have also improved on all the parsing issues of
my last submission for assignment 2, so I would also like this assignment to be considered
for improving my mark on that assignment.

- The output from a successfull is an AST with type information that may look something like this:

pring the tree!
Checking semantics
Semantics are good!
Program 
	Var Int u @1
	Var Int y @2
Func Void test @6
 
Func Int gcd @10
	Return Expression @9: INT: 7
Func Void temp @16
 	Int[] Param x @12
	Var Int z @13
	Expression @15 of type INT: z == INT: 10
Func Int main @36
	Var Int x @19
	Var Int y @19
	Var Int[5] z @19
	Expression @20 of type INT: x = INT: y
	Expression @22 of type INT[]: z[INT: 4] = INT: 10
	Expression @24 of type VOIDFUNC: temp(INT[]: z)
	Expression @26 of type INT: gcd() * 1
	Expression @28 of type INT: x = INTFUNC: gcd()
	If Expression @36: INT: y = INT: x
		if statment @36: 
			If Expression @36: INT: x = INT: 4
				if statment @35: 
					If Expression @35: INT: y == INT: 2
						if statment @33: 
							Return Expression @33: INT: u
						else statement @35: 
							Expression @35 of type INT: y = INT: 2

- This output can be interpreted as a program that meets the requirments on the c- grammar and semantic rules.
All expressions are marked by their types, and further type information of components is included when
it may be useful. I chose to not show the unique identifires for variables with the same name that are in
seperate scopes, since only one can be reffered to at a time (the one in the lowest scope), making something like
an id for it somewhat redundant, since the one the user is referring to can only be the one in the lowest scope.

- There are also 3 test files containing multiple tests each for the seperate types of checks we implemented for this assignment. You can run a test by uncommenting it, and then running the program against the file. What is being tested and the expected output is specified on each test.

NOTE: I implemented my analyzer using c, and used some gnu libraries (glib-2.0) so that 
I could have access to some nicely implemented hash tables. As such, you will need to compile
this program from a linux device that has these gnu tools installed (basically all of them.)
I checked that my program compiles on the univeristy Linux Lab machines and it does. I'm not
sure if it can be ran from an osx device.

COMPILE AND RUN - to compile my program run the following commands

1. make flex

2. make bison

3. make compile

this will create a program called 'parser' which you can use by running

./parser <name of file you would like to test against>